# -*- coding: utf-8 -*-
"""Çabalıyorum Senaryo III.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vhU_jHtDuuhGcIEvB6nZmphIU8hSwjjt
"""

import cvxpy as cp
import numpy as np
import pandas as pd
import warnings

warnings.filterwarnings("ignore", category=UserWarning, module="openpyxl")
from google.colab import drive
drive.mount('/content/drive')

# Excel dosya yolu
excel_path = "/content/drive/MyDrive/Tilburg University/OP FOR DS/Data OPT for DS.xlsx"

# ---------- Nodes ----------
df_nodes = pd.read_excel(excel_path, sheet_name="Nodes", engine="openpyxl")
beneficiary_camps = df_nodes[df_nodes["LocationTYpe"] == "Beneficiary Camp"]["Location"].unique()
ports = df_nodes[df_nodes["LocationTYpe"] == "Port"]["Location"].unique()
warehouses = df_nodes[df_nodes["LocationTYpe"] == "Warehouse"]["Location"].unique()
beneficiaries_dict = dict(zip(df_nodes["Location"], df_nodes["#Beneficiaries"].fillna(0)))
port_capacity_dict = dict(zip(df_nodes["Location"], df_nodes["Port capacity (mt/month)"].fillna(0)))
handling_cost_dict = dict(zip(df_nodes["Location"], df_nodes["Handling cost ($/ton)"].fillna(0)))
warehouse_cap_dict = dict(zip(df_nodes["Location"], df_nodes.get("Warehouse capacity", pd.Series()).fillna(0)))
warehouse_handling_dict = {wh: 0 for wh in warehouses}

# ---------- Commodities ----------
df_commodities = pd.read_excel(excel_path, sheet_name="Commodities", engine="openpyxl")
df_commodities["Commodity"] = df_commodities["Commodity"].str.upper().str.strip().str.rstrip("S")
commodities = df_commodities["Commodity"].unique()

# ---------- Nutrients (Daily Requirements) ----------
df_nutrients = pd.read_excel(excel_path, sheet_name="Nutrients", engine="openpyxl")
df_nutrients.columns = ["Nutrient", "Daily Requirement"]
df_nutrients["Nutrient"] = df_nutrients["Nutrient"].str.upper().str.replace(".", "").str.strip()
df_nutrients["Daily Requirement"] = df_nutrients["Daily Requirement"].astype(str).str.replace(",", ".").astype(float)
nutrient_names = df_nutrients["Nutrient"].unique()
daily_req_dict = dict(zip(df_nutrients["Nutrient"], df_nutrients["Daily Requirement"]))

# ---------- Nutritional Values (Pivot) ----------
df_nutr_values = pd.read_excel(excel_path, sheet_name="Nutritional values", engine="openpyxl")
df_nutr_values.rename(columns=lambda x: x.strip(), inplace=True)
nutr_value_col = "Nutritional value (value/100 gram)!!"
df_nutr_values["Commodity"] = df_nutr_values["Commodity"].str.upper().str.strip().str.rstrip("S")
df_nutr_values["Nutrient"] = (df_nutr_values["Nutrient"]
                              .str.upper()
                              .str.replace(".", "")
                              .str.strip())
nutr_value_df = df_nutr_values.pivot(index="Commodity", columns="Nutrient", values=nutr_value_col).fillna(0)
nutr_value_df.columns = [col.upper().replace(".", "").strip() for col in nutr_value_df.columns]
nutr_value_df.index = nutr_value_df.index.str.upper().str.strip()
commodity_list_nutr = nutr_value_df.index.tolist()
nutr_list_nutr = nutr_value_df.columns.tolist()

conversion_factor = 10000
nutr_matrix = np.zeros((len(commodity_list_nutr), len(nutr_list_nutr)))
for i, com in enumerate(commodity_list_nutr):
    for j, nut in enumerate(nutr_list_nutr):
        val_100g = nutr_value_df.loc[com, nut]
        nutr_matrix[i, j] = float(str(val_100g).replace(",", ".")) * conversion_factor

# ---------- Procurement ----------
df_proc = pd.read_excel(excel_path, sheet_name="Procurement", engine="openpyxl")
df_proc["Supplier"] = df_proc["Supplier"].astype(str).str.strip().str.upper()
df_proc["Commodity"] = df_proc["Commodity"].astype(str).str.strip().str.upper().str.rstrip("S")
suppliers = df_proc["Supplier"].unique().tolist()
commodities_proc = df_proc["Commodity"].unique().tolist()
n_suppliers = len(suppliers)
n_commodities_proc = len(commodities_proc)
capacity = np.zeros((n_suppliers, n_commodities_proc))
proc_cost = np.zeros((n_suppliers, n_commodities_proc))
for i, sup in enumerate(suppliers):
    for j, com in enumerate(commodities_proc):
        row = df_proc[(df_proc["Supplier"] == sup) & (df_proc["Commodity"] == com)]
        if not row.empty:
            capacity[i, j] = row["Procurement capacity (ton/month)"].values[0]
            proc_cost[i, j] = row["Procurement price ($/ton)"].values[0]
        else:
            capacity[i, j] = 0
            proc_cost[i, j] = 1e6

# ---------- SeaTransport ----------
df_sea = pd.read_excel(excel_path, sheet_name="SeaTransport", engine="openpyxl")
sea_cost_dict = {}
for row in df_sea.itertuples(index=False):
    key = (row.Origin, row.Destination, row.Commodity)
    sea_cost_dict[key] = row[3]

# ---------- LandTransport ----------
df_land = pd.read_excel(excel_path, sheet_name="LandTransport", engine="openpyxl")
land_cost_dict = {}
for row in df_land.itertuples(index=False):
    key = (row.Origin, row.Destination)
    land_cost_dict[key] = row[2]

ports = list(ports)
warehouses = list(warehouses)
beneficiary_camps = list(beneficiary_camps)
days = 30

# ============ Model Building and Solving Function ============
def build_and_solve_model(beneficiaries_dict_local, port_capacity_dict_local, warehouse_cap_dict_local,
                          scenario_name="Base", nutrient_req_multiplier=1.0):
    """
    Builds and solves the integrated LP/MILP model.
    nutrient_req_multiplier allows us to relax (or tighten) the nutrient daily requirements.
    """
    # Slack parameters
    penalty_demand_param = cp.Parameter(nonneg=True, value=1e4)
    penalty_nutr_param   = cp.Parameter(nonneg=True, value=1e6)
    demand_slacks = {}
    nutr_slacks = {}
    constraint_groups = {}

    # Decision variables (continuous)
    x = cp.Variable((n_suppliers, len(ports), n_commodities_proc), nonneg=True)
    sea_flow = cp.Variable((len(ports), len(ports), n_commodities_proc), nonneg=True)
    y = cp.Variable((len(ports), len(warehouses), n_commodities_proc), nonneg=True)
    z = cp.Variable((len(warehouses), len(beneficiary_camps), n_commodities_proc), nonneg=True)

    # MILP: Binary variable for supplier usage
    supplier_active = cp.Variable(n_suppliers, boolean=True)
    supplier_M = np.sum(capacity, axis=1)  # Big‑M: total capacity per supplier

    # (A) Supplier Capacity and MILP Big‑M constraint
    constraint_groups["supplier_capacity"] = []
    for s in range(n_suppliers):
        for f in range(n_commodities_proc):
            constraint_groups["supplier_capacity"].append(cp.sum(x[s, :, f]) <= capacity[s, f])
        # If supplier s is inactive, no flow is allowed
        constraint_groups["supplier_capacity"].append(cp.sum(x[s, :, :]) <= supplier_M[s] * supplier_active[s])

    # (B) Port Flow Balance: Supplier -> Sea
    constraint_groups["port_flow_balance"] = []
    for p in range(len(ports)):
        for f in range(n_commodities_proc):
            constraint_groups["port_flow_balance"].append(
                cp.sum(x[:, p, f]) == cp.sum(sea_flow[p, :, f])
            )

    # (C) Port Balance: Sea -> Warehouse
    constraint_groups["port_balance"] = []
    for d in range(len(ports)):
        for f in range(n_commodities_proc):
            constraint_groups["port_balance"].append(
                cp.sum(sea_flow[:, d, f]) == cp.sum(y[d, :, f])
            )

    # (D) Warehouse Balance and Capacity
    constraint_groups["warehouse_balance"] = []
    for w, wh_name in enumerate(warehouses):
        if wh_name in warehouse_cap_dict_local and warehouse_cap_dict_local[wh_name] > 0:
            constraint_groups["warehouse_balance"].append(
                cp.sum(z[w, :, :]) <= warehouse_cap_dict_local[wh_name]
            )
        for f in range(n_commodities_proc):
            constraint_groups["warehouse_balance"].append(
                cp.sum(y[:, w, f]) == cp.sum(z[w, :, f])
            )

    # (E) Port Capacity
    constraint_groups["port_capacity"] = []
    for p, port_name in enumerate(ports):
        port_cap = port_capacity_dict_local.get(port_name, 0)
        if port_cap > 0:
            constraint_groups["port_capacity"].append(
                cp.sum(x[:, p, :]) <= port_cap
            )

    # (F) Camp Demand Constraint
    # Here we assume that the nutritional constraints will ensure the camps are fed,
    # so we set min_food_per_person = 0.0.
    constraint_groups["camp_demand"] = []
    for c, camp_name in enumerate(beneficiary_camps):
        camp_population = beneficiaries_dict_local.get(camp_name, 0)
        min_food_per_person = 0.0
        base_demand = camp_population * min_food_per_person
        slack = cp.Variable(nonneg=True)
        demand_slacks[c] = slack
        constraint_groups["camp_demand"].append(
            cp.sum(z[:, c, :]) + slack >= base_demand
        )

    # (G) Nutrient Constraints
    constraint_groups["nutritional"] = []
    new_nutr_matrix = np.zeros((n_commodities_proc, len(nutr_list_nutr)))
    for f, com in enumerate(commodities_proc):
        if com in commodity_list_nutr:
            idx = commodity_list_nutr.index(com)
            new_nutr_matrix[f, :] = nutr_matrix[idx, :]
        else:
            print(f"⚠️ Warning: {com} not found in nutrient values, assigning zero.")
            new_nutr_matrix[f, :] = np.zeros(len(nutr_list_nutr))

    # Relax nutrient daily requirements by nutrient_req_multiplier (e.g., 0.9 means a 10% relaxation)
    for c, camp_name in enumerate(beneficiary_camps):
        camp_population = beneficiaries_dict_local.get(camp_name, 0)
        for j, nutr_name in enumerate(nutr_list_nutr):
            if nutr_name not in daily_req_dict:
                continue
            base_req = daily_req_dict[nutr_name] * nutrient_req_multiplier * days * camp_population
            slack_nutr = cp.Variable(nonneg=True)
            nutr_slacks[(c, j)] = slack_nutr
            constraint_groups["nutritional"].append(
                cp.sum(cp.multiply(z[:, c, :], new_nutr_matrix[:, j].reshape(1, -1))) + slack_nutr >= base_req
            )

    # Combine all constraints
    all_constraints = []
    for group in constraint_groups.values():
        all_constraints += group

    # Cost functions
    def calc_procurement_cost(x, proc_cost):
        n_ports_local = x.shape[1]
        proc_cost_rep = np.tile(proc_cost[:, None, :], (1, n_ports_local, 1))
        return cp.sum(cp.multiply(x, proc_cost_rep))

    def calc_sea_transport_cost(sea_flow):
        cost = 0
        for p in range(len(ports)):
            for d in range(len(ports)):
                for f_idx, com in enumerate(commodities_proc):
                    key = (ports[p], ports[d], com)
                    cost_val = sea_cost_dict.get(key, 0)
                    cost += cost_val * sea_flow[p, d, f_idx]
        return cost

    def calc_port_handling_cost(x):
        cost = 0
        for p, port_name in enumerate(ports):
            handle_c = handling_cost_dict.get(port_name, 0)
            cost += handle_c * cp.sum(x[:, p, :])
        return cost

    def calc_land_transport_cost(y):
        cost = 0
        for p, port_name in enumerate(ports):
            for w, wh_name in enumerate(warehouses):
                key = (port_name, wh_name)
                land_c = land_cost_dict.get(key, 0)
                cost += land_c * cp.sum(y[p, w, :])
        return cost

    def calc_warehouse_handling_cost(y):
        cost = 0
        for w, wh_name in enumerate(warehouses):
            wh_c = warehouse_handling_dict.get(wh_name, 0)
            cost += wh_c * cp.sum(y[:, w, :])
        return cost

    def calc_warehouse_to_camp_cost(z):
        cost = 0
        for w, wh_name in enumerate(warehouses):
            for c, camp_name in enumerate(beneficiary_camps):
                key = (wh_name, camp_name)
                land_c = land_cost_dict.get(key, 0)
                cost += land_c * cp.sum(z[w, c, :])
        return cost

    cost_procurement = calc_procurement_cost(x, proc_cost)
    cost_sea_transport = calc_sea_transport_cost(sea_flow)
    cost_port_handling = calc_port_handling_cost(x)
    cost_port_to_wh = calc_land_transport_cost(y)
    cost_wh_handling = calc_warehouse_handling_cost(y)
    cost_wh_to_camp = calc_warehouse_to_camp_cost(z)

    total_cost = (cost_procurement + cost_sea_transport + cost_port_handling +
                  cost_port_to_wh + cost_wh_handling + cost_wh_to_camp)

    penalty_cost = penalty_demand_param * cp.sum(list(demand_slacks.values())) \
                   + penalty_nutr_param * cp.sum(list(nutr_slacks.values()))
    total_cost_with_slack = total_cost + penalty_cost

    objective = cp.Minimize(total_cost_with_slack)
    lp_problem = cp.Problem(objective, all_constraints)

    print(f"\n=== Solving Scenario: {scenario_name} ===")
    result_lp = lp_problem.solve(solver=cp.GLPK_MI, verbose=False)
    print("Solver Status:", lp_problem.status)
    print("Optimal Total Cost (with penalties):", result_lp)

    total_demand_slack = sum(slack.value for slack in demand_slacks.values())
    total_nutr_slack = sum(slack.value for slack in nutr_slacks.values())
    print("Total Demand Slack:", total_demand_slack)
    print("Total Nutritional Slack:", total_nutr_slack)

    # --- Compute Percentage of Camps Fully Fed ---
    fed_count = 0
    for c in range(len(beneficiary_camps)):
        fed = True
        for j in range(len(nutr_list_nutr)):
            # If any nutritional slack is above a small threshold, assume the camp is not fully fed.
            if (c, j) in nutr_slacks and nutr_slacks[(c, j)].value > 1e-6:
                fed = False
                break
        if fed:
            fed_count += 1
    percent_fed = (fed_count / len(beneficiary_camps)) * 100
    print("Percentage of Camps Fully Fed:", percent_fed, "%")

    return lp_problem, result_lp

# ============ Base Case (Normal Scenario) ============
base_problem, base_result = build_and_solve_model(beneficiaries_dict, port_capacity_dict, warehouse_cap_dict, scenario_name="Base Case")

# ============ Scenario 1: Demand Increase ============
beneficiaries_dict_scenario1 = beneficiaries_dict.copy()
for camp, pop in beneficiaries_dict_scenario1.items():
    beneficiaries_dict_scenario1[camp] = pop * 1.10  # Increase camp population by 10%

scenario1_problem, scenario1_result = build_and_solve_model(beneficiaries_dict_scenario1, port_capacity_dict, warehouse_cap_dict, scenario_name="Scenario 1 (Demand +10%)")

# ============ Scenario 2: First Port Capacity Reduction ============
port_capacity_dict_scenario2 = port_capacity_dict.copy()
if len(ports) > 0:
    port_name_to_reduce = ports[0]
    port_capacity_dict_scenario2[port_name_to_reduce] = port_capacity_dict_scenario2[port_name_to_reduce] * 0.5  # Reduce capacity by 50%

scenario2_problem, scenario2_result = build_and_solve_model(beneficiaries_dict, port_capacity_dict_scenario2, warehouse_cap_dict, scenario_name="Scenario 2 (First Port Capacity 50%)")

# ============ Scenario 3: Nutrient Requirement Relaxation ============
# Relax daily nutrient requirements by 10% (i.e. use 90% of the original values)
scenario3_problem, scenario3_result = build_and_solve_model(beneficiaries_dict, port_capacity_dict, warehouse_cap_dict, scenario_name="Scenario 3 (Nutrient Requirements 90%)", nutrient_req_multiplier=0.9)



Solver Status: optimal
Optimal Total Cost (with penalties): 33546944.932476312
Total Demand Slack: 0.0
Total Nutritional Slack: 0.0
Percentage of Camps Fully Fed: 100.0 %

=== Solving Scenario: Scenario 1 (Demand +10%) ===
Solver Status: optimal
Optimal Total Cost (with penalties): 34344282.14894474
Total Demand Slack: 0.0
Total Nutritional Slack: 0.0
Percentage of Camps Fully Fed: 100.0 %

=== Solving Scenario: Scenario 2 (First Port Capacity 50%) ===
Solver Status: optimal
Optimal Total Cost (with penalties): 31845688.732844986
Total Demand Slack: 0.0
Total Nutritional Slack: 0.0
Percentage of Camps Fully Fed: 100.0 %

=== Solving Scenario: Scenario 3 (Nutrient Requirements 90%) ===
Solver Status: optimal
Optimal Total Cost (with penalties): 29292418.707144257
Total Demand Slack: 0.0
Total Nutritional Slack: 0.0
Percentage of Camps Fully Fed: 100.0 %