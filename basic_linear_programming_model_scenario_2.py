# -*- coding: utf-8 -*-
"""Basic_Linear_Programming_Model_Scenario_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PNjv4_dJbYY9bNsujFAhV_a4SgZp5uky
"""

import cvxpy as cp
import numpy as np
import pandas as pd
import warnings

warnings.filterwarnings("ignore", category=UserWarning, module="openpyxl")
from google.colab import drive
drive.mount('/content/drive')

# Path to the Excel file
excel_path = "/content/drive/MyDrive/Tilburg University/OP FOR DS/Data OPT for DS.xlsx"

########################################
### Function: Create and solve the LP model
########################################
def solve_lp_model(modify_constraints=None, modify_port_capacity=None):
    """
    modify_constraints: A function to modify constraint values (e.g., "camp_demand").
      For example, modify_constraints("camp_demand", base_value, camp_norm)
      would return the modified value.
    modify_port_capacity: For the port capacity constraint,
      a function: modify_port_capacity(port_norm, base_cap).
      For example, to reduce capacity by 30%, return base_cap*0.7.
    """
    ### 1. Nodes Sheet: Read data and normalize
    df_nodes = pd.read_excel(excel_path, sheet_name="Nodes", engine="openpyxl")
    beneficiary_camps = df_nodes[df_nodes["LocationTYpe"].str.upper().str.strip() == "BENEFICIARY CAMP"]["Location"]\
                          .str.replace("[<>]", "", regex=True).unique()
    ports = df_nodes[df_nodes["LocationTYpe"].str.upper().str.strip() == "PORT"]["Location"]\
            .str.replace("[<>]", "", regex=True).unique()
    warehouses = df_nodes[df_nodes["LocationTYpe"].str.upper().str.strip() == "WAREHOUSE"]["Location"]\
                 .str.replace("[<>]", "", regex=True).unique()

    beneficiaries_dict = dict(zip(
        df_nodes["Location"].str.upper().str.strip().str.replace("[<>]", "", regex=True),
        df_nodes["#Beneficiaries"].fillna(0)
    ))
    port_capacity_dict = dict(zip(
        df_nodes[df_nodes["LocationTYpe"].str.upper().str.strip() == "PORT"]["Location"]
            .str.upper().str.strip().str.replace("[<>]", "", regex=True),
        df_nodes[df_nodes["LocationTYpe"].str.upper().str.strip() == "PORT"]["Port capacity (mt/month)"].fillna(0)
    ))
    handling_cost_dict = dict(zip(
        df_nodes["Location"].str.upper().str.strip().str.replace("[<>]", "", regex=True),
        df_nodes["Handling cost ($/ton)"].fillna(0)
    ))
    warehouse_cap_dict = dict(zip(
        df_nodes[df_nodes["LocationTYpe"].str.upper().str.strip() == "WAREHOUSE"]["Location"]
            .str.upper().str.strip().str.replace("[<>]", "", regex=True),
        df_nodes[df_nodes["LocationTYpe"].str.upper().str.strip() == "WAREHOUSE"]["Port capacity (mt/month)"].fillna(0)
    ))
    warehouse_handling_dict = dict(zip(
        df_nodes[df_nodes["LocationTYpe"].str.upper().str.strip() == "WAREHOUSE"]["Location"]
            .str.upper().str.strip().str.replace("[<>]", "", regex=True),
        df_nodes[df_nodes["LocationTYpe"].str.upper().str.strip() == "WAREHOUSE"]["Handling cost ($/ton)"]
            .fillna(0).astype(float)
    ))
    location_type_dict = dict(zip(
        df_nodes["Location"].str.upper().str.strip().str.replace("[<>]", "", regex=True),
        df_nodes["LocationTYpe"].str.upper().str.strip()
    ))

    ### 2. Commodities, Nutrients, Nutritional Values Sheets
    df_commodities = pd.read_excel(excel_path, sheet_name="Commodities", engine="openpyxl")
    df_commodities["Commodity"] = df_commodities["Commodity"].str.upper().str.strip()
    commodities = df_commodities["Commodity"].unique()

    df_nutrients = pd.read_excel(excel_path, sheet_name="Nutrients", engine="openpyxl")
    df_nutrients.columns = ["Nutrient", "Daily Requirement"]
    df_nutrients["Nutrient"] = df_nutrients["Nutrient"].str.upper().str.replace(".", "").str.strip()
    df_nutrients["Daily Requirement"] = df_nutrients["Daily Requirement"]\
        .astype(str).str.replace(",", ".").astype(float)
    nutrient_names = df_nutrients["Nutrient"].unique()
    daily_req_dict = dict(zip(df_nutrients["Nutrient"], df_nutrients["Daily Requirement"]))

    df_nutr_values = pd.read_excel(excel_path, sheet_name="Nutritional values", engine="openpyxl")
    df_nutr_values.rename(columns=lambda x: x.strip(), inplace=True)
    nutr_value_col = "Nutritional value (value/100 gram)!!"
    df_nutr_values["Commodity"] = df_nutr_values["Commodity"].str.upper().str.strip()
    df_nutr_values["Nutrient"] = df_nutr_values["Nutrient"].str.upper().str.replace(".", "").str.strip()
    nutr_value_df = df_nutr_values.pivot(index="Commodity", columns="Nutrient", values=nutr_value_col).fillna(0)
    nutr_value_df.columns = [col.upper().replace(".", "").strip() for col in nutr_value_df.columns]
    nutr_value_df.index = nutr_value_df.index.str.upper().str.strip()
    commodity_list_nutr = nutr_value_df.index.tolist()
    nutr_list_nutr = nutr_value_df.columns.tolist()
    conversion_factor = 10000
    nutr_matrix = np.zeros((len(commodity_list_nutr), len(nutr_list_nutr)))
    for i, com in enumerate(commodity_list_nutr):
        for j, nut in enumerate(nutr_list_nutr):
            val_100g = nutr_value_df.loc[com, nut]
            nutr_matrix[i, j] = float(str(val_100g).replace(",", ".")) * conversion_factor

    ### 3. Procurement Sheet
    df_proc = pd.read_excel(excel_path, sheet_name="Procurement", engine="openpyxl")
    df_proc["Supplier"] = df_proc["Supplier"].astype(str).str.strip().str.upper()
    df_proc["Commodity"] = df_proc["Commodity"].astype(str).str.strip().str.upper()
    suppliers = df_proc["Supplier"].unique().tolist()
    commodities_proc = df_proc["Commodity"].unique().tolist()
    n_suppliers = len(suppliers)
    n_commodities_proc = len(commodities_proc)
    capacity = np.zeros((n_suppliers, n_commodities_proc))
    proc_cost = np.zeros((n_suppliers, n_commodities_proc))
    for i, sup in enumerate(suppliers):
        for j, com in enumerate(commodities_proc):
            row = df_proc[(df_proc["Supplier"] == sup) & (df_proc["Commodity"] == com)]
            if not row.empty:
                capacity[i, j] = row["Procurement capacity (ton/month)"].values[0]
                proc_cost[i, j] = row["Procurement price ($/ton)"].values[0]
            else:
                capacity[i, j] = 0
                proc_cost[i, j] = 1e3

    ### 4. LandTransport Sheet
    df_land = pd.read_excel(excel_path, sheet_name="LandTransport", engine="openpyxl")
    df_land["Origin_Normalized"] = df_land["Origin"].str.upper().str.strip().str.replace("[<>]", "", regex=True)
    df_land["Destination_Normalized"] = df_land["Destination"].str.upper().str.strip().str.replace("[<>]", "", regex=True)
    df_land["Origin_Type"] = df_land["Origin_Normalized"].map(location_type_dict)
    df_land["Destination_Type"] = df_land["Destination_Normalized"].map(location_type_dict)
    df_port_to_wh = df_land[(df_land["Origin_Type"] == "PORT") & (df_land["Destination_Type"] == "WAREHOUSE")].copy()
    df_wh_to_camp = df_land[(df_land["Origin_Type"] == "WAREHOUSE") & (df_land["Destination_Type"] == "BENEFICIARY CAMP")].copy()
    land_cost_port_to_wh = {
        (row.Origin_Normalized, row.Destination_Normalized): row[2]
        for row in df_port_to_wh.itertuples(index=False)
    }
    land_cost_wh_to_camp = {
        (row.Origin_Normalized, row.Destination_Normalized): row[2]
        for row in df_wh_to_camp.itertuples(index=False)
    }

    ### 5. SeaTransport Sheet
    df_sea = pd.read_excel(excel_path, sheet_name="SeaTransport", engine="openpyxl")
    df_sea["Origin"] = df_sea["Origin"].str.upper().str.strip()
    df_sea["Destination"] = df_sea["Destination"].str.upper().str.strip()
    df_sea["Commodity"] = df_sea["Commodity"].str.upper().str.strip()
    sea_cost_dict = {}
    for _, row in df_sea.iterrows():
        key = (row["Origin"], row["Destination"], row["Commodity"])
        sea_cost_dict[key] = row["SeaTransport cost ($/ton)"]

    ### 6. Dimensions and other parameters
    all_nodes = list(ports) + list(warehouses) + list(beneficiary_camps)
    n_ports = len(ports)
    n_warehouses = len(warehouses)
    n_camps = len(beneficiary_camps)
    days = 30

    ### 7. Decision Variables
    x = cp.Variable((n_suppliers, n_ports, n_commodities_proc), nonneg=True)
    y = cp.Variable((n_ports, n_warehouses, n_commodities_proc), nonneg=True)
    z = cp.Variable((n_warehouses, n_camps, n_commodities_proc), nonneg=True)

    ### 8. Extra Constraints (Allow only routes defined in Excel)
    constraint_groups_extra = []
    # Port-to-Warehouse:
    for p in range(n_ports):
        port_norm = ports[p].upper().strip()
        for w in range(n_warehouses):
            wh_norm = warehouses[w].upper().strip()
            if (port_norm, wh_norm) not in land_cost_port_to_wh:
                for f in range(n_commodities_proc):
                    constraint_groups_extra.append(y[p, w, f] == 0)
    # Warehouse-to-Camp:
    for w in range(n_warehouses):
        wh_norm = warehouses[w].upper().strip()
        for c in range(n_camps):
            camp_norm = beneficiary_camps[c].upper().strip()
            if (wh_norm, camp_norm) not in land_cost_wh_to_camp:
                for f in range(n_commodities_proc):
                    constraint_groups_extra.append(z[w, c, f] == 0)
    # SeaTransport: only allow defined combinations
    for s in range(n_suppliers):
        for p in range(n_ports):
            for f in range(n_commodities_proc):
                key = (suppliers[s], ports[p], commodities_proc[f])
                if key not in sea_cost_dict:
                    constraint_groups_extra.append(x[s, p, f] == 0)

    ### 9. Constraint Groups
    constraint_groups = {}
    # Supplier Capacity:
    for s in range(n_suppliers):
        for f in range(n_commodities_proc):
            constraint_groups.setdefault("supplier_capacity", []).append(cp.sum(x[s, :, f]) <= capacity[s, f])

    # Port Balance:
    for p in range(n_ports):
        for f in range(n_commodities_proc):
            constraint_groups.setdefault("port_balance_direct", []).append(
                cp.sum(x[:, p, f]) == cp.sum(y[p, :, f])
            )

    # Warehouse Balance:
    for w, wh_name in enumerate(warehouses):
        wh_norm = wh_name.upper().strip()
        # If a warehouse has a capacity > 0, add this constraint:
        if wh_norm in warehouse_cap_dict and warehouse_cap_dict[wh_norm] > 0:
            constraint_groups.setdefault("warehouse_balance", []).append(
                cp.sum(z[w, :, :]) <= warehouse_cap_dict[wh_norm]
            )
        # Flow In = Flow Out for each commodity:
        for f in range(n_commodities_proc):
            constraint_groups.setdefault("warehouse_balance", []).append(
                cp.sum(y[:, w, f]) == cp.sum(z[w, :, f])
            )

    # Port Capacity: apply modify_port_capacity if provided
    for p, port_name in enumerate(ports):
        port_norm = port_name.upper().strip()
        port_cap = port_capacity_dict.get(port_norm, 0)
        if modify_port_capacity is not None:
            port_cap = modify_port_capacity(port_norm, port_cap)
        if port_cap > 0:
            constraint_groups.setdefault("port_capacity", []).append(cp.sum(x[:, p, :]) <= port_cap)

    # Camp Demand:
    min_food_per_person_daily_g = 300  # grams
    for c, camp_name in enumerate(beneficiary_camps):
        camp_norm = camp_name.upper().strip()
        camp_population = beneficiaries_dict.get(camp_norm, 0)
        base_demand = camp_population * days * min_food_per_person_daily_g / 1_000_000
        if modify_constraints is not None:
            base_demand = modify_constraints("camp_demand", base_demand, camp_norm)
        constraint_groups.setdefault("camp_demand", []).append(cp.sum(z[:, c, :]) >= base_demand)

    # Nutritional Constraints:
    for c in range(n_camps):
        camp_norm = beneficiary_camps[c].upper().strip()
        camp_population = beneficiaries_dict.get(camp_norm, 0)
        for j, nutr_name in enumerate(nutr_list_nutr):
            if nutr_name not in daily_req_dict:
                continue
            base_req = daily_req_dict[nutr_name] * days * camp_population
            constraint_groups.setdefault("nutritional", []).append(
                cp.sum(cp.multiply(z[:, c, :], np.tile(nutr_matrix[:, j], (1,)))) >= base_req
            )
            # We define this slack variable only to track the surplus for shadow price;
            # we are not adding it to the cost:
            slack_nutr = cp.Variable(nonneg=True, name=f"nutr_surplus_{c}_{j}")
            constraint_groups.setdefault("nutritional_tracking", []).append(
                slack_nutr == cp.sum(cp.multiply(z[:, c, :], np.tile(nutr_matrix[:, j], (1,)))) - base_req
            )

    # Add extra route constraints:
    constraint_groups.setdefault("route_availability", []).extend(constraint_groups_extra)

    # Combine all constraints into a single list:
    all_constraints = []
    for group in constraint_groups.values():
        all_constraints += group

    ### 10. Cost Functions
    def calc_procurement_cost(x, proc_cost):
        n_ports_local = x.shape[1]
        proc_cost_rep = np.tile(proc_cost[:, None, :], (1, n_ports_local, 1))
        return cp.sum(cp.multiply(x, proc_cost_rep))

    def calc_port_handling_cost(x, handling_cost_dict):
        cost = 0
        for p, port_name in enumerate(ports):
            port_norm = port_name.upper().strip()
            handle_c = handling_cost_dict.get(port_norm, 0)
            cost += handle_c * cp.sum(x[:, p, :])
        return cost

    def calc_land_transport_cost(y, land_cost_dict):
        cost = 0
        for p, port_name in enumerate(ports):
            port_norm = port_name.upper().strip()
            for w, wh_name in enumerate(warehouses):
                key = (port_norm, wh_name.upper().strip())
                land_c = land_cost_dict.get(key, 0)
                cost += land_c * cp.sum(y[p, w, :])
        return cost

    def calc_warehouse_handling_cost(y, warehouse_handling_dict):
        cost = 0
        for w, wh_name in enumerate(warehouses):
            wh_norm = wh_name.upper().strip()
            wh_c = warehouse_handling_dict.get(wh_norm, 0)
            cost += wh_c * cp.sum(y[:, w, :])
        return cost

    def calc_warehouse_to_camp_cost(z, land_cost_dict):
        cost = 0
        for w, wh_name in enumerate(warehouses):
            wh_norm = wh_name.upper().strip()
            for c, camp_name in enumerate(beneficiary_camps):
                camp_norm = camp_name.upper().strip()
                key = (wh_norm, camp_norm)
                land_c = land_cost_dict.get(key, 0)
                cost += land_c * cp.sum(z[w, c, :])
        return cost

    def calc_sea_transport_cost(x, sea_cost_dict):
        cost = 0
        for s, supplier in enumerate(suppliers):
            for p, port in enumerate(ports):
                for f, commodity in enumerate(commodities_proc):
                    key = (supplier, port, commodity)
                    sea_c = sea_cost_dict.get(key, 0)
                    cost += sea_c * x[s, p, f]
        return cost

    cost_procurement = calc_procurement_cost(x, proc_cost)
    cost_sea_transport = calc_sea_transport_cost(x, sea_cost_dict)
    cost_port_handling = calc_port_handling_cost(x, handling_cost_dict)
    cost_port_to_wh = calc_land_transport_cost(y, land_cost_port_to_wh)
    cost_wh_handling = calc_warehouse_handling_cost(y, warehouse_handling_dict)
    cost_wh_to_camp = calc_warehouse_to_camp_cost(z, land_cost_wh_to_camp)

    total_cost = (
        cost_procurement
        + cost_port_handling
        + cost_sea_transport
        + cost_port_to_wh
        + cost_wh_handling
        + cost_wh_to_camp
    )

    objective = cp.Minimize(total_cost)
    lp_problem = cp.Problem(objective, all_constraints)

    result = lp_problem.solve(solver=cp.SCS, verbose=False)

    # Additional outputs: total tonnage, unit cost, cost per person per day, etc.
    total_ton = sum(
        x.value[s, p, f] for s in range(n_suppliers)
                         for p in range(n_ports)
                         for f in range(n_commodities_proc)
    )
    if total_ton > 0:
        cost_per_ton = total_cost.value / total_ton
    else:
        cost_per_ton = None

    total_population = sum(beneficiaries_dict.get(camp.upper().strip(), 0) for camp in beneficiary_camps)
    if total_population > 0:
        cost_per_person_per_day = total_cost.value / (total_population * days)
    else:
        cost_per_person_per_day = None

    # Simple assumption: If all camp demands are met, the population that can be fed = total camp population.
    fed_population = total_population

    return {
        "status": lp_problem.status,
        "total_cost": total_cost.value,
        "cost_per_ton": cost_per_ton,
        "cost_per_person_per_day": cost_per_person_per_day,
        "total_ton": total_ton,
        "fed_population": fed_population,
        "decision_vars": {"x": x.value, "y": y.value, "z": z.value}
    }

########################################
### Baseline Scenario (Original Model)
########################################
print("\n########### Baseline Scenario ###########")
baseline_results = solve_lp_model()
print("LP Solver Status:", baseline_results["status"])
print("Total Cost: ${:.2f}".format(baseline_results["total_cost"]))
if baseline_results["cost_per_ton"] is not None:
    print("Unit Cost (Per Ton): ${:.2f}".format(baseline_results["cost_per_ton"]))
if baseline_results["cost_per_person_per_day"] is not None:
    print("Cost per Person per Day: ${:.2f}".format(baseline_results["cost_per_person_per_day"]))
print("Total Transported Tonnage:", baseline_results["total_ton"])
print("Total Population that can be Fed (Minimum):", baseline_results["fed_population"])

########################################
### Scenario 1: 20% Increase in Demand
########################################
print("\n########### Scenario 1: 20% Increase in Demand ###########")
def modify_for_demand(constraint_type, base_value, camp_norm):
    # If the constraint type is 'camp_demand', we increase the demand by 20%.
    if constraint_type == "camp_demand":
        return base_value * 1.2
    return base_value

scenario1_results = solve_lp_model(modify_constraints=modify_for_demand)
print("LP Solver Status:", scenario1_results["status"])
print("Total Cost: ${:.2f}".format(scenario1_results["total_cost"]))
if scenario1_results["cost_per_ton"] is not None:
    print("Unit Cost (Per Ton): ${:.2f}".format(scenario1_results["cost_per_ton"]))
if scenario1_results["cost_per_person_per_day"] is not None:
    print("Cost per Person per Day: ${:.2f}".format(scenario1_results["cost_per_person_per_day"]))
print("Total Transported Tonnage:", scenario1_results["total_ton"])
print("Total Population that can be Fed (Minimum):", scenario1_results["fed_population"])

########################################
### Scenario 2: 30% Reduction in Port Capacity
########################################
print("\n########### Scenario 2: 30% Reduction in Port Capacity ###########")
def reduce_port_capacity(port_norm, base_cap):
    # Reduce port capacity by 30%.
    return base_cap * 0.7

scenario2_results = solve_lp_model(modify_port_capacity=reduce_port_capacity)
print("LP Solver Status:", scenario2_results["status"])
print("Total Cost: ${:.2f}".format(scenario2_results["total_cost"]))
if scenario2_results["cost_per_ton"] is not None:
    print("Unit Cost (Per Ton): ${:.2f}".format(scenario2_results["cost_per_ton"]))
if scenario2_results["cost_per_person_per_day"] is not None:
    print("Cost per Person per Day: ${:.2f}".format(scenario2_results["cost_per_person_per_day"]))
print("Total Transported Tonnage:", scenario2_results["total_ton"])
print("Total Population that can be Fed (Minimum):", scenario2_results["fed_population"])